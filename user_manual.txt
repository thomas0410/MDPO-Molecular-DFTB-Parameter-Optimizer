# MDPO — Molecular DFTB Parameter Optimizer: User Manual

## 1\. Overview

MDPO (Molecular DFTB Parameter Optimizer) is a Python tool for optimizing Slater-Koster files (SKFs) used in Density-Functional Tight-Binding (DFTB) calculations, specifically with the `dftb+` software.

The primary goal is to adjust the parameters within the SKF files to minimize the error between the `dftb+` calculations and a set of high-level reference values (e.g., from DFT or experimental data).

It uses the Simultaneous Perturbation Stochastic Approximation (SPSA) algorithm, which is well-suited for high-dimensional optimization problems where the gradient (the "loss" vs. SKF parameters) is unknown or too expensive to compute.

## 2\. Key Features

  * **SPSA Optimization:** Efficiently optimizes SKF parameters without needing to compute analytical gradients.
  * **Targeted Corrections:** Can optimize the Hamiltonian matrix elements ($H$), the repulsive potential (Spline/Polynomial), or both.
  * **Multi-Target Optimization:** Can simultaneously optimize for multiple physical quantities, such as ground-state energy (S0) and excitation energies.
  * **Flexible Correction Model:** Applies corrections using different basis functions (Polynomial, B-spline, Sigmoid).
  * **Parallel Execution:** Runs multiple `dftb+` calculations in parallel for efficient batch evaluation.
  * **Checkpointing:** Automatically saves and resumes training, allowing you to stop and continue optimization later.
  * **Template Generation:** Automatically generates a `dftb_in.hsd` template based on the SKF files you provide.

## 3\. Requirements

  * **Python 3:** With the `numpy` library installed.
    ```bash
    pip install numpy
    ```
  * **`dftb+` Executable:** The `dftb+` program must be installed and accessible in your system's `PATH`. The script calls it directly using the command `dftb+`.

## 4\. Project Setup & Directory Structure

The script expects a specific directory structure to function correctly.

```
/your_project_directory/
├── opt_SKFs_v7_notConfirm.py  # <-- The MDPO script
|
├── SKFs/                     # <-- (Input) Your original SKF files
│   ├── C-C.skf
│   ├── C-H.skf
│   ├── Sn-Sn.skf
│   ├── Sn-C.skf
│   ├── ...
│
├── data/                     # <-- (Input) Your reference geometry files
│   ├── struct1.xyz
│   ├── struct2.xyz
│   └── ...
|
├── ref.txt                   # <-- (Input) Your reference data file
|
├── templates/                # <-- (Generated) Will be created by the script
│   └── dftb_in.hsd
|
└── runs/                     # <-- (Generated) For logs, checkpoints, and temp files
    ├── spsa_ckpt.pkl
    └── ...
```

**Output:** Optimized files will be saved in `SKFs/optimized/`.

## 5\. How to Run: Step-by-Step Workflow

### Step 1: Create the Directory Structure

Create the project layout as shown in section 4.

### Step 2: Prepare Your SKF Files

Place *all* necessary Slater-Koster files for your calculations into the `SKFs/` directory. This includes both the files you *intend to optimize* and any other files required by `dftb+` (e.g., `O-H.skf`, `C-O.skf`, etc.).

### Step 3: Prepare Your Reference Data

1.  **Geometries:** Place all your reference geometry files (e.g., `struct1.xyz`, `benzene.xyz`) into the `data/` directory.

2.  **Reference Values (`ref.txt`):** Create the `ref.txt` file. Each line must correspond to a file in the `data/` directory and provide the reference values you are optimizing against.

    The format of this file depends on the `--targets` command-line flag (default is `both`):

      * **`--targets both` (Default):**
        ```
        # Format: <geometry_file> <S0_energy_eV> <Excitation_energy_eV>
        struct1.xyz  -150.1234  3.5
        struct2.xyz  -160.5678  3.2
        ```
      * **`--targets energy`:**
        ```
        # Format: <geometry_file> <S0_energy_eV>
        struct1.xyz  -150.1234
        struct2.xyz  -160.5678
        ```

### Step 4: Configure the Optimization Script

Open the `opt_SKFs_v7_notConfirm.py` script and go to the `main()` function at the very bottom (around line 1250). You **must** configure the two variables in the "Central Configuration Block":

1.  **`SKF_PAIRS_TO_OPTIMIZE`:** List the file *stems* (names without `.skf`) of the pairs you want to optimize. The script automatically handles symmetric pairs (e.g., `Sn-C` and `C-Sn`).

    ```python
    # Example:
    SKF_PAIRS_TO_OPTIMIZE = ["Sn-Sn", "Sn-C", "Sn-O", "Sn-H"]
    ```

2.  **`EXTRA_HSD_BLOCK`:** This multi-line string will be injected into the `dftb_in.hsd` template. This is where you *must* add the DFTB+ settings required to calculate your targets.

      * If optimizing `Excitation` (the default), you **must** add the `ExcitedState { Casida ... }` block here.
      * If you need to change `MaxAngularMomentum`, you can also add it here.

    <!-- end list -->

    ```python
    # Example:
    EXTRA_HSD_BLOCK = """
    ExcitedState {
        Casida {
            NrOfExcitations = 10
            Symmetry = Singlet
            Diagonaliser = Arpack{}
        }
    }
    """.strip()
    ```

### Step 5: Run the Script

Once your files are in place and the script is configured, run it from your project's root directory:

```bash
python3 opt_SKFs_v7_notConfirm.py
```

The script will:

1.  Read all your files.
2.  Generate the `templates/dftb_in.hsd` file.
3.  Start the SPSA optimization loop.
4.  Print progress to the console.

## 6\. Monitoring, Stopping, and Resuming

  * **Monitoring:** Progress is printed to the console. A new "best val loss" indicates the optimizer has found a better set of parameters.
  * **Checkpointing:** The script automatically saves its progress (the current `theta` parameters) to `runs/spsa_ckpt.pkl`.
  * **Resuming:** If the script is stopped (e.g., with `Ctrl+C`) or crashes, simply run it again. It will automatically detect and load the `spsa_ckpt.pkl` file and resume from where it left off.
  * **Stopping Gracefully:** To stop the script cleanly after its current step, create a `.STOP` file in the `runs/` directory:
    ```bash
    touch runs/spsa_ckpt.STOP
    ```
    The script will detect this file, save a final checkpoint, and exit gracefully.

## 7\. Output

When the optimization is complete (or stopped), the best-performing set of parameters is used to generate the final SKF files. These are saved in **`SKFs/optimized/`**.

The original files in `SKFs/` are never modified.

## 8\. Key Configuration Options (Command Line)

You can modify the optimization behavior using command-line arguments.

  * `--targets`: (Default: `both`)
      * `both`: Optimize for S0 and Excitation energy.
      * `energy`: Optimize for S0 energy only.
      * `excitation`: Optimize for Excitation energy only.
  * `--opt-scope`: (Default: `both`)
      * `both`: Optimize Hamiltonian and Repulsive potential.
      * `ham`: Optimize Hamiltonian only.
      * `repulsive`: Optimize Repulsive potential only.
  * `--basis`: (Default: `poly`)
      * `poly`: Use Legendre polynomials for the correction function.
      * `bspline`: Use B-splines.
      * `sigmoid`: Use a sum of sigmoid functions.
  * `--K`: (Default: `2`)
      * The number of basis functions (e.g., degree of polynomial, number of splines/sigmoids). A higher `K` allows for more complex corrections but is harder to optimize.

### Data Sampling Strategy

The script uses a specific data sampling strategy to speed up training, which is **only enabled for large datasets**.

  * **Small Datasets (Automatic):** If your `ref.txt` has fewer than 100 entries, the script will *ignore* all sampling settings and **use the entire dataset** for every optimization step.
  * **Large Datasets (Sampling):**
      * `--permanent`: (Default: `1,201,401`) A comma-separated list of 1-based indices from `ref.txt` to *always* include in every batch.
      * `--strata`: (Default: `1-200,201-400,401-600`) Defines "pools" of data for stratified sampling.
      * `--batch-F`: (Default: `40`) The number of random structures to pull from the "floating" data pool (non-permanent data) for each gradient step.
